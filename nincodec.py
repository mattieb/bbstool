# $Id$
#
# Copyright (c) 2005 Matt Behrens.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
# KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
Codec for converting Nintendo 8-bit Japanese encoding, as seen in
Daigasso! Band Brothers save data
"""

# Based on the Shift-JIS table in Band Brothers Music Editor
# <http://www.maid.gr.jp/jubai/bandbrothers>

import codecs

decode_map = codecs.make_identity_dict(range(256))
decode_map.update({                            0x86: 0x3092, 0x87: 0x3041, 
                   0x88: 0x3043, 0x89: 0x3045, 0x8a: 0x3047, 0x8b: 0x3049, 
                   0x8c: 0x3083, 0x8d: 0x3085, 0x8e: 0x3087, 0x8f: 0x3063, 
                   0x90: 0x301c, 0x91: 0x3042, 0x92: 0x3044, 0x93: 0x3046, 
                   0x94: 0x3048, 0x95: 0x304a, 0x96: 0x304b, 0x97: 0x304d, 
                   0x98: 0x304f, 0x99: 0x3051, 0x9a: 0x3053, 0x9b: 0x3055, 
                   0x9c: 0x3057, 0x9d: 0x3059, 0x9e: 0x305b, 0x9f: 0x305d, 
                                 0xa1: 0x3002, 0xa2: 0x300c, 0xa3: 0x300d, 
                   0xa4: 0x3001, 0xa5: 0x30fb, 0xa6: 0x30f2, 0xa7: 0x30a1, 
                   0xa8: 0x30a3, 0xa9: 0x30a5, 0xaa: 0x30a7, 0xab: 0x30a9, 
                   0xac: 0x30e3, 0xad: 0x30e5, 0xae: 0x30e7, 0xaf: 0x30c3, 
                   0xb0: 0x2212, 0xb1: 0x30a2, 0xb2: 0x30a4, 0xb3: 0x30a6, 
                   0xb4: 0x30a8, 0xb5: 0x30aa, 0xb6: 0x30ab, 0xb7: 0x30ad, 
                   0xb8: 0x30af, 0xb9: 0x30b1, 0xba: 0x30b3, 0xbb: 0x30b5, 
                   0xbc: 0x30b7, 0xbd: 0x30b9, 0xbe: 0x30bb, 0xbf: 0x30bd, 
                   0xc0: 0x30bf, 0xc1: 0x30c1, 0xc2: 0x30c4, 0xc3: 0x30c6, 
                   0xc4: 0x30c8, 0xc5: 0x30ca, 0xc6: 0x30cb, 0xc7: 0x30cc, 
                   0xc8: 0x30cd, 0xc9: 0x30ce, 0xca: 0x30cf, 0xcb: 0x30d2, 
                   0xcc: 0x30d5, 0xcd: 0x30d8, 0xce: 0x30db, 0xcf: 0x30de, 
                   0xd0: 0x30df, 0xd1: 0x30e0, 0xd2: 0x30e1, 0xd3: 0x30e2, 
                   0xd4: 0x30e4, 0xd5: 0x30e6, 0xd6: 0x30e8, 0xd7: 0x30e9, 
                   0xd8: 0x30ea, 0xd9: 0x30eb, 0xda: 0x30ec, 0xdb: 0x30ed, 
                   0xdc: 0x30ef, 0xdd: 0x30f3, 0xde: 0x309b, 0xdf: 0x309c, 
                   0xe0: 0x305f, 0xe1: 0x3061, 0xe2: 0x3064, 0xe3: 0x3066, 
                   0xe4: 0x3068, 0xe5: 0x306a, 0xe6: 0x306b, 0xe7: 0x306c, 
                   0xe8: 0x306d, 0xe9: 0x306e, 0xea: 0x306f, 0xeb: 0x3072, 
                   0xec: 0x3075, 0xed: 0x3078, 0xee: 0x307b, 0xef: 0x307e, 
                   0xf0: 0x307f, 0xf1: 0x3080, 0xf2: 0x3081, 0xf3: 0x3082, 
                   0xf4: 0x3084, 0xf5: 0x3086, 0xf6: 0x3088, 0xf7: 0x3089, 
                   0xf8: 0x308a, 0xf9: 0x308b, 0xfa: 0x308c, 0xfb: 0x308d,
                   0xfc: 0x308f, 0xfd: 0x3093, 0xfe: 0x2605})

encode_map = dict([(v, k) for k, v in decode_map.iteritems()])

class Codec(codecs.Codec):
    def encode(self, input, errors='strict'):
        return codecs.charmap_encode(input, errors, encode_map)

    def decode(self, input, errors='strict'):
        return codecs.charmap_decode(input, errors, decode_map)

class StreamWriter(Codec, codecs.StreamWriter):
    pass

class StreamReader(Codec, codecs.StreamReader):
    pass

def getregentry():
    return Codec().encode, Codec().decode, StreamReader, StreamWriter

def nincodec_search(name):
    if name == 'nintendo':
        return getregentry()
    return None

codecs.register(nincodec_search)

# ex:et:sw=4:ts=4
